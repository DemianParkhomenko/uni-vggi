// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
attribute vec2 texCoord;
attribute vec3 tangent;

uniform mat4 ModelViewMatrix;
uniform mat4 ProjectionMatrix;

varying vec3 vPosition;   // position in eye space
varying vec2 vTexCoord;
varying vec3 vT;
varying vec3 vB;
varying vec3 vN;

void main() {
    vec4 posEye = ModelViewMatrix * vec4(vertex, 1.0);
    vPosition = posEye.xyz;
    vTexCoord = texCoord;

    mat3 MV3 = mat3(ModelViewMatrix);

    // Transform normal and tangent to eye space
    vec3 T = MV3 * tangent;
    vec3 N = MV3 * normal;

    // === Gramâ€“Schmidt, giving PRIORITY to tangent ===
    // First, normalize tangent -> primary basis vector
    T = normalize(T);

    // Then make normal orthogonal to tangent
    N = normalize(N - T * dot(N, T));

    // Bitangent completes TBN
    vec3 B = cross(N, T);

    vT = T;
    vB = B;
    vN = N;

    gl_Position = ProjectionMatrix * posEye;
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec3 vPosition;
varying vec2 vTexCoord;
varying vec3 vT;
varying vec3 vB;
varying vec3 vN;

uniform vec3 uLightPos;      // light position in eye space

uniform sampler2D uDiffuseMap;
uniform sampler2D uNormalMap;
uniform sampler2D uSpecularMap;

uniform vec3 uAmbientColor;
uniform vec3 uDiffuseColor;
uniform vec3 uSpecularColor;
uniform float uShininess;

// Debug mode: 0=shaded, 1=diffuse tex, 2=normal tex, 3=specular tex
uniform int uDebugMode;
// Texture tiling multiplier
uniform float uTexScale;

void main() {
    // Build TBN matrix (eye space)
    vec3 T = normalize(vT);
    vec3 B = normalize(vB);
    vec3 N = normalize(vN);
    mat3 TBN = mat3(T, B, N);

    // UV with tiling
    vec2 uv = vTexCoord * uTexScale;

    // Normal from normal map (tangent space -> eye space)
    vec3 nTex = texture2D(uNormalMap, uv).rgb;
    nTex = nTex * 2.0 - 1.0;   // [0,1] -> [-1,1]
    vec3 Neye = normalize(TBN * nTex);

    // Lighting vectors
    vec3 L = normalize(uLightPos - vPosition);
    float lambert = max(dot(Neye, L), 0.0);

    // Viewer direction: from fragment to eye (eye at origin in eye space)
    vec3 V = normalize(-vPosition);
    vec3 R = reflect(-L, Neye);
    float spec = 0.0;
    if (lambert > 0.0) {
        spec = pow(max(dot(R, V), 0.0), uShininess);
    }

    // Sample textures
    vec3 texDiffuse   = texture2D(uDiffuseMap,   uv).rgb;
    float texSpecular = texture2D(uSpecularMap, uv).r;

    // Debug outputs
    if (uDebugMode == 1) {
        gl_FragColor = vec4(texDiffuse, 1.0);
        return;
    } else if (uDebugMode == 2) {
        // Show normal map in RGB (tangent space), remapped to [0,1]
        gl_FragColor = vec4(0.5 * (nTex + 1.0), 1.0);
        return;
    } else if (uDebugMode == 3) {
        gl_FragColor = vec4(vec3(texSpecular), 1.0);
        return;
    }

    // Final shaded color
    vec3 color =
        uAmbientColor * texDiffuse +
        uDiffuseColor * lambert * texDiffuse +
        uSpecularColor * spec * texSpecular;

    gl_FragColor = vec4(color, 1.0);
}`;
